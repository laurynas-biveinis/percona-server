# ==== Purpose ====
#
# This test is executed twice for each test case. Before every
# testcase it is run with mysqltest in record mode and will thus
# produce an output file that can be compared to output from after the
# tescase.  In that way, it is possible to check that a testcase does
# not have any unwanted side affects.

--disable_query_log

# Wait for any connections opened by a previous testcase (or the testcase
# warning checker) to finish closing. Exclude binlog dump threads as these may
# linger around indefinitely.
--disable_result_log
SET @expected_thread_count= 1;
--let $event_scheduler_running= `SELECT @@event_scheduler = 'ON'`
if ($event_scheduler_running == 1)
{
  SET @expected_thread_count= @expected_thread_count + 1;
}
--enable_result_log
--let $wait_condition=SELECT COUNT(*)=@expected_thread_count FROM INFORMATION_SCHEMA.PROCESSLIST WHERE COMMAND != 'Binlog Dump';
--source include/wait_condition.inc
if (!$success)
{
  SELECT * FROM INFORMATION_SCHEMA.PROCESSLIST;
}

# We want to ensure all slave configuration is restored.  But SHOW
# SLAVE STATUS returns nothing for servers not configured as slaves,
# and (after BUG#28796 was fixed) there is no way to de-configure a
# slave.  Hence, it's impossible to clean up the replication state at
# the end.  But we want to check that the slave is stopped, there is
# no error, and a few other invariants.  So we issue SHOW SLAVE
# STATUS, and if it returns no rows we fake the result.
--let $tmp= query_get_value(SHOW SLAVE STATUS, Slave_IO_Running, 1)
--let $tmp= `SELECT '$tmp' = 'No such row'`
if ($tmp)
{
  # Note: after WL#5177, fields 13-18 shall not be filtered-out.
  --echo Slave_IO_State	
  --echo Master_Host	127.0.0.1
  --echo Master_User	root
  --echo Master_Port	#
  --echo Connect_Retry	#
  --echo Master_Log_File	#
  --echo Read_Master_Log_Pos	#
  --echo Relay_Log_File	#
  --echo Relay_Log_Pos	#
  --echo Relay_Master_Log_File	#
  --echo Slave_IO_Running	No
  --echo Slave_SQL_Running	No
  --echo Replicate_Do_DB	#
  --echo Replicate_Ignore_DB	#
  --echo Replicate_Do_Table	#
  --echo Replicate_Ignore_Table	#
  --echo Replicate_Wild_Do_Table	#
  --echo Replicate_Wild_Ignore_Table	#
  --echo Last_Errno	0
  --echo Last_Error	
  --echo Skip_Counter	0
  --echo Exec_Master_Log_Pos	#
  --echo Relay_Log_Space	#
  --echo Until_Condition	#
  --echo Until_Log_File	#
  --echo Until_Log_Pos	#
  --echo Master_SSL_Allowed	No
  --echo Master_SSL_CA_File	
  --echo Master_SSL_CA_Path	
  --echo Master_SSL_Cert	
  --echo Master_SSL_Cipher	
  --echo Master_SSL_Key	
  --echo Seconds_Behind_Master	NULL
  --echo Master_SSL_Verify_Server_Cert	No
  --echo Last_IO_Errno	0
  --echo Last_IO_Error	
  --echo Last_SQL_Errno	0
  --echo Last_SQL_Error	
  --echo Replicate_Ignore_Server_Ids	
  --echo Master_Server_Id	#
}
if (!$tmp) {
  # Note: after WL#5177, fields 13-18 shall not be filtered-out.
  --replace_column 4 # 5 # 6 # 7 # 8 # 9 # 10 # 13 # 14 # 15 # 16 # 17 # 18 # 22 # 23 # 24 # 25 # 26 # 40 #
  query_vertical
  SHOW SLAVE STATUS;
}

--write_file $MYSQL_TMP_DIR/list
$MYSQL_TMP_DIR:
EOF
--list_files_append_file $MYSQL_TMP_DIR/list $MYSQL_TMP_DIR
--append_file $MYSQL_TMP_DIR/list
$MYSQLTEST_VARDIR:
EOF
--list_files_append_file $MYSQL_TMP_DIR/list $MYSQLTEST_VARDIR
--let $input_file= $MYSQL_TMP_DIR/list
--let $script= s{check-mysqld_.\.result}{};
--source include/filter_file.inc
--cat_file $MYSQL_TMP_DIR/list
--remove_file $MYSQL_TMP_DIR/list

call mtr.check_testcase();
--enable_query_log

